\section{Assessment}

\subsection{Advantages}

\begin{itemize}
\item The format is ultimately streaming: the decoder never has to have
      more than sizeof(double) into its buffer, no 'looking back' is
      ever required.
\item In spite of that, a complex structure a la JSON/XML/ASN.1 can be
      encoded.
\item In fact, using the larger concept, \textit{any} structure can
      be encoded (so long as there are no value intrinsic constraints, such
      as 'this value is a prime number', or 'this value is three times the
      previous value').
\item While the decoder cannot fail.
\item Therefore, cannot fail mid-decoding either (you can receive
      partial messages and still have a valid encoding).
\end{itemize}

\subsection{Disadvantages}

\begin{itemize}
\item (In this implementation:)
      string encoding carries a penalty of 12.5\% overhead in the limit.
\item Encoding and decoding may not be deterministically linked: the same
      chaos may not be returned when passed through the decoder and encoder
      subsequently (the reverse order however, from JSON to binary to JSON,
      does deterministically link the encoder and the decoder - provided
      JSON hashtable keys are sorted).
\item Although correction of inputs - when not using error correcting codes -
      is neigh on impossible in all popular formats, they can usually
      provide some feedback. With this format, feedback to the user
      ('this is where your input went wrong') is impossible.
\item (When decoding random inputs:) null bytes in strings are possible,
      Unicode won't be produced
      (because there exist invalid Unicode sequences), and duplicate
      keys in key/value structures are a possibility (although JSON
      leaves this behaviour undefined).
\item Conversely, Unicode support won't be possible in the encoder.
\end{itemize}
